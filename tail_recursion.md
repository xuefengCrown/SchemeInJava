
尾递归是指递归调用是函数的最后一个语句，而且其结果被直接返回，这是一类特殊的递归调用。
由于递归结果总是直接返回，尾递归比较方便转换为循环，因此编译器容易对它进行优化。

尾递归版本最重要的就是找到合适的累加器，该累加器可以保留最后一次递归调用留在堆栈中的数据，
积累之前调用的结果，这样堆栈数据就可以被丢弃，当前的函数栈可以被重复利用。 

普通递归：

    def recsum(x):
      if x == 1:
        return x
      else:
        return x + recsum(x - 1)

调用recsum(5)为例，SICP中描述了相应的栈空间变化[7]：

    recsum(5)
    5 + recsum(4)
    5 + (4 + recsum(3))
    5 + (4 + (3 + recsum(2)))
    5 + (4 + (3 + (2 + recsum(1))))
    5 + (4 + (3 + (2 + 1)))
    5 + (4 + (3 + 3))
    5 + (4 + 6)
    5 + 10
    15

可观察，堆栈从左到右，增加到一个峰值后再计算从右到左缩小，这往往是我们不希望的，所以在C语言等语言中设计for, while, goto等特殊结构语句，使用迭代、尾递归，对普通递归进行优化，减少可能对内存的极端消耗。修改以上代码，可以成为尾递归：

    def tailrecsum(x, running_total=0):
      if x == 0:
        return running_total
      else:
        return tailrecsum(x - 1, running_total + x)

或者使用迭代：

    for i in range(6):
      sum += i

对比后者尾递归对内存的消耗：

    tailrecsum(5, 0) 
    tailrecsum(4, 5) 
    tailrecsum(3, 9)
    tailrecsum(2, 12) 
    tailrecsum(1, 14) 
    tailrecsum(0, 15) 
    15

则是线性的。


尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，
只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。

    function f() {
      let m = 1;
      let n = 2;
      return g(m + n);
    }
    f();
    
    // 等同于
    function f() {
      return g(3);
    }
    f();
    
    // 等同于
    g(3);
    

上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，
函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。

"尾调用优化"对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，
所有 ECMAScript 的实现，都必须部署"尾调用优化"。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。

总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，
这就是为什么尾递归对这些语言极其重要。



