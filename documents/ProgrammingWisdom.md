
[王垠：编程的智慧](http://blog.jobbole.com/95763/)

### 优雅的代码
优雅的代码的另一个特征是，它的逻辑大体上看起来，是枝丫分明的树状结构（tree）。
这是因为程序所做的几乎一切事情，都是信息的传递和分支。

### 真正的模块化
真正的模块化，并不是文本意义上的，而是逻辑意义上的。一个模块应该像一个电路芯片，它有定义良好的输入和输出。
实际上一种很好的模块化方法早已经存在，它的名字叫做“函数”。每一个函数都有明确的输入（参数）和输出（返回值），
同一个文件里可以包含多个函数，所以你其实根本不需要把代码分开在多个文件或者目录里面，同样可以完成代码的模块化。
我可以把代码全都写在同一个文件里，却仍然是非常模块化的代码。

1. 避免写太长的函数。
2. 制造小的工具函数。
如果你仔细观察代码，就会发现其实里面有很多的重复。这些常用的代码，不管它有多短，提取出去做成函数，都可能是会有好处的。
3. 每个函数只做一件简单的事情。
4. 避免使用全局变量和类成员（class member）来传递信息，尽量使用局部变量和参数。

### 写可读的代码
有些人以为写很多注释就可以让代码更加可读，然而却发现事与愿违。注释不但没能让代码变得可读，
反而由于大量的注释充斥在代码中间，让程序变得障眼难读。而且代码的逻辑一旦修改，就会有很多的注释变得过时，需要更新。
修改注释是相当大的负担，所以大量的注释，反而成为了妨碍改进代码的绊脚石。

实际上，真正优雅可读的代码，是几乎不需要注释的。如果你发现需要写很多注释，那么你的代码肯定是含混晦涩，逻辑不清晰的。
其实，程序语言相比自然语言，是更加强大而严谨的，它其实具有自然语言最主要的元素：主语，谓语，宾语，名词，动词，如果，那么，
否则，是，不是，…… 所以如果你充分利用了程序语言的表达能力，你完全可以用程序本身来表达它到底在干什么，而不需要自然语言的辅助。

有少数的时候，你也许会为了绕过其他一些代码的设计问题，采用一些违反直觉的作法。这时候你可以使用很短注释，说明为什么要写成那奇怪的样子。
这样的情况应该少出现，否则这意味着整个代码的设计都有问题。

如果没能合理利用程序语言提供的优势，你会发现程序还是很难懂，以至于需要写注释。
所以我现在告诉你一些要点，也许可以帮助你大大减少写注释的必要：
1. 使用有意义的函数和变量名字。如果你的函数和变量的名字，能够切实的描述它们的逻辑，那么你就不需要写注释来解释它在干什么。比如：

  put(elephant1, fridge2);
 
2. 局部变量应该尽量接近使用它的地方。
语句的文本中顺序 && 运行时顺序
如果你看透了局部变量的本质——它们就是电路里的导线，那你就能更好的理解近距离的好处。
变量定义离用的地方越近，导线的长度就越短。你不需要摸着一根导线，绕来绕去找很远，
就能发现接收它的端口，这样的电路就更容易理解。

3. 局部变量名字应该简短。

4. 不要重用局部变量。

5. 把复杂的逻辑提取出去，做成“帮助函数”。
有些人写的函数很长，以至于看不清楚里面的语句在干什么，所以他们误以为需要写注释。如果你仔细观察这些代码，
就会发现不清晰的那片代码，往往可以被提取出去，做成一个函数，然后在原来的地方调用。由于函数有一个名字，
这样你就可以使用有意义的函数名来代替注释。

6. 把复杂的表达式提取出去，做成中间变量。

7. 在合理的地方换行。

### 写简单的代码
程序语言都喜欢标新立异，提供这样那样的“特性”，然而有些特性其实并不是什么好东西。很多特性都经不起时间的考验，
最后带来的麻烦，比解决的问题还多。很多人盲目的追求“短小”和“精悍”，或者为了显示自己头脑聪明，学得快，所以喜欢
利用语言里的一些特殊构造，写出过于“聪明”，难以理解的代码。

并不是语言提供什么，你就一定要把它用上的。实际上你只需要其中很小的一部分功能，就能写出优秀的代码。
我一向反对“充分利用”程序语言里的所有特性。实际上，我心目中有一套最好的构造。不管语言提供了多么“神奇”的，
“新”的特性，我基本都只用经过千锤百炼，我觉得值得信任的那一套。

现在针对一些有问题的语言特性，我介绍一些我自己使用的代码规范，并且讲解一下为什么它们能让代码更简单。
1. 避免使用自增减表达式（i++，++i，i–，–i）。
这种自增减操作表达式其实是历史遗留的设计失误。它们含义蹊跷，非常容易弄错。
它们把读和写这两种完全不同的操作，混淆缠绕在一起，把语义搞得乌七八糟。
含有它们的表达式，结果可能取决于求值顺序，所以它可能在某种编译器下能正确运行，换一个编译器就出现离奇的错误。
其实这两个表达式完全可以分解成两步，把读和写分开：一步更新i的值，另外一步使用i的值。

2. 永远不要省略花括号。

3. 合理使用括号，不要盲目依赖操作符优先级。

4. 避免使用continue和break。
循环语句（for，while）里面出现return是没问题的，然而如果你使用了continue或者break，
就会让循环的逻辑和终止条件变得复杂，难以确保正确。出现continue或者break的原因，往往是对循环的逻辑没有想清楚。
如果你考虑周全了，应该是几乎不需要continue或者break的。如果你的循环里出现了continue或者break，你就应该考虑改写这个循环。

改写循环的办法有多种：
    如果出现了continue，你往往只需要把continue的条件反向，就可以消除continue。
    如果出现了break，你往往可以把break的条件，合并到循环头部的终止条件里，从而去掉break。
    有时候你可以把break替换成return，从而去掉break。
    如果以上都失败了，你也许可以把循环里面复杂的部分提取出来，做成函数调用，之后continue或者break就可以去掉了。
    
### 写直观的代码
我写代码有一条重要的原则：如果有更加直接，更加清晰的写法，就选择它，即使它看起来更长，更笨，也一样选择它。
scheme中的 and or 就很不直接 (其实，这种写法是滥用了逻辑操作&&和||的短路特性。)

### 写无懈可击的代码

使用这种方式，其实是为了无懈可击的处理所有可能出现的情况，避免漏掉corner case。
每个if语句都有两个分支的理由是：如果if的条件成立，你做某件事情；但是如果if的条件不成立，你应该知道要做什么另外的事情。
不管你的if有没有else，你终究是逃不掉，必须得思考这个问题的。
如果我漏写了else分支，Java编译器是不会放过我的。它会抱怨：“在某个分支，s没有被初始化。”
这就强迫我清清楚楚的设定各种条件下s的值，不漏掉任何一种情况。

### 正确处理错误
使用有两个分支的if语句，只是我的代码可以达到无懈可击的其中一个原因。
这样写if语句的思路，其实包含了使代码可靠的一种通用思想：穷举所有的情况，不漏掉任何一个。

程序的绝大部分功能，是进行信息处理。从一堆纷繁复杂，模棱两可的信息中，排除掉绝大部分“干扰信息”，找到自己需要的那一个。
正确地对所有的“可能性”进行推理，就是写出无懈可击代码的核心思想。这一节我来讲一讲，如何把这种思想用在错误处理上。

很多初学者，都会忘记检查read的返回值是否为-1，觉得每次调用read都得检查返回值真繁琐，不检查貌似也相安无事。
这种想法其实是很危险的。如果函数的返回值告诉你，要么返回一个正数，表示读到的数据长度，要么返回-1，那么你就
必须要对这个-1作出相应的，有意义的处理。千万不要以为你可以忽视这个特殊的返回值，因为它是一种“可能性”。
代码漏掉任何一种可能出现的情况，都可能产生意想不到的灾难性结果。

如果你把异常catch了，忽略掉，那么你就不知道foo其实失败了。这就像开车时看到路口写着“前方施工，道路关闭”，还继续往前开。
这当然迟早会出问题，因为你根本不知道自己在干什么。

catch异常的时候，你不应该使用Exception这么宽泛的类型。你应该正好catch可能发生的那种异常A。使用宽泛的异常类型有很大的问题，
因为它会不经意的catch住另外的异常（比如B）。你的代码逻辑是基于判断A是否出现，可你却catch所有的异常（Exception类），
所以当其它的异常B出现的时候，你的代码就会出现莫名其妙的问题，因为你以为A出现了，而其实它没有。
这种bug，有时候甚至使用debugger都难以发现。

如果你在自己函数的类型加上throws Exception，那么你就不可避免的需要在调用它的地方处理这个异常，
如果调用它的函数也写着throws Exception，这毛病就传得更远。
**我的经验是，尽量在异常出现的当时就作出处理。**
否则如果你把它返回给你的调用者，它也许根本不知道该怎么办了。

### 正确处理null指针
1. 尽量不要产生null指针。尽量不要用null来初始化变量，函数尽量不要返回null。
如果你的函数要返回“没有”，“出错了”之类的结果，尽量使用Java的异常机制。

2. 不要把null放进“容器数据结构”里面。
所谓容器（collection），是指一些对象以某种方式集合在一起，所以null不应该被放进Array，List，Set等结构，
不应该出现在Map的key或者value里面。把null放进容器里面，是一些莫名其妙错误的来源。因为对象在容器里的位置一般是动态决定的，
所以一旦null从某个入口跑进去了，你就很难再搞明白它去了哪里，你就得被迫在所有从这个容器里取值的位置检查null。
你也很难知道到底是谁把它放进去的，代码多了就导致调试极其困难。解决方案是：如果你真要表示“没有”，那你就干脆不要
把它放进去（Array，List，Set没有元素，Map根本没那个entry），或者你可以指定一个特殊的，真正合法的对象，用来表示“没有”。
需要指出的是，类对象并不属于容器。所以null在必要的时候，可以作为对象成员的值，表示它不存在。

3. 函数调用者：明确理解null所表示的意义，尽早检查和处理null返回值，减少它的传播。
null很讨厌的一个地方，在于它在不同的地方可能表示不同的意义。有时候它表示“没有”，“没找到”。有时候它表示“出错了”，“失败了”。
有时候它甚至可以表示“成功了”，…… 这其中有很多误用之处，不过无论如何，你必须理解每一个null的意义，不能给混淆起来。
如果你调用的函数有可能返回null，那么你应该在第一时间对null做出“有意义”的处理。
我的意思是，使用这函数的人，应该明确的知道在拿到null的情况下该怎么做，承担起责任来。他不应该只是“向上级汇报”，把责任踢给自己的调用者。

4. 函数作者：明确声明不接受null参数，当参数是null时立即崩溃。不要试图对null进行“容错”，不要让程序继续往下执行。

5. 使用@NotNull和@Nullable标记。
IntelliJ提供了@NotNull和@Nullable两种标记，加在类型前面，这样可以比较简洁可靠地防止null指针的出现。

**?????????????????????**
6. 使用Optional类型。Java 8和Swift之类的语言，提供了一种叫Optional的类型。正确的使用这种类型，可以在很大程度上避免null的问题。
null指针的问题之所以存在，是因为你可以在没有“检查”null的情况下，“访问”对象的成员。Optional类型的设计原理，就是把“检查”和“访问”
这两个操作合二为一，成为一个“原子操作”。这样你没法只访问，而不进行检查。这种做法其实是ML，Haskell等语言里的模式匹配（pattern matching）
的一个特例。模式匹配使得类型判断和访问成员这两种操作合二为一，所以你没法犯错。

Java 8的做法比较蹩脚一些。如果你得到一个Optional类型的值found，你必须使用“函数式编程”的方式，来写这之后的代码：
Optional found = find();
found.ifPresent(content -> System.out.println("found: " + content));

这段Java代码跟上面的Swift代码等价，它包含一个“判断”和一个“取值”操作。ifPresent先判断found是否有值（相当于判断是不是null）。
如果有，那么将其内容“绑定”到lambda表达式的content参数（unwrap操作），然后执行lambda里面的内容，否则如果found没有内容，
那么ifPresent里面的lambda不执行。

Java的这种设计有个问题。判断null之后分支里的内容，全都得写在lambda里面。在函数式编程里，这个lambda叫做“continuation”，Java把它叫做
“Consumer”，它表示“如果found不是null，拿到它的值，然后应该做什么”。由于lambda是个函数，你不能在里面写return语句返回出外层的函数。

总之你只要记住，使用Optional类型，要点在于“原子操作”，使得null检查与取值合二为一。

### 防止过度工程
这就是为什么很多软件项目如此复杂。实际上没做多少事情，却为了所谓的“将来”，加入了很多不必要的复杂性。
眼前的问题还没解决呢，就被“将来”给拖垮了。人们都不喜欢目光短浅的人，然而在现实的工程中，有时候你就是得看近一点，
把手头的问题先搞定了，再谈以后扩展的问题。

另外一种过度工程的来源，是过度的关心“代码重用”。很多人“可用”的代码还没写出来呢，就在关心“重用”。

过度地关心“测试”，也会引起过度工程。

根据这些，我总结出来的防止过度工程的原则如下：
1. 先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。
2. 先写出可用的代码，反复推敲，再考虑是否需要重用的问题。
3. 先写出可用，简单，明显没有bug的代码，再考虑测试的问题。

















